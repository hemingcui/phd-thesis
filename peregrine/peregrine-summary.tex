\section{Summary} \label{sec:peregrine-summary}

\peregrine is one of the first stable and fully deterministic system with good
efficiency.
Leveraging the insight that races are rare, \peregrine combines sync-schedules
and mem-schedules into hybrid schedules, getting the benefits of both.
\peregrine reuses schedules across different inputs, amortizing the cost of
computing hybrid schedules and making program behaviors repeatable
across inputs.  It further improves
efficiency using two new techniques: determinism-preserving slicing to
generalize a schedule to more inputs while preserving determinism, and
schedule-guided simplification to precisely analyze a program according
to a dynamic schedule.  Our evaluation on a diverse set of programs
shows that \peregrine is both deterministic and efficient, and can frequently
reuse schedules for half of the evaluated programs.


\peregrine's system and ideas have broad applications.  Our immediate future
work is to build applications on top of \peregrine, such as fast deterministic
replay, replication, and diversification systems.  We will also extend our
approach to system-wide deterministic execution by computing inter-process
communication schedules and preconditions.  \peregrine enables precise program
analysis according to a set of inputs and dynamic schedules.  We will
leverage this capability to accurately detect concurrency errors and
verify concurrency-error-freedom for real programs.

