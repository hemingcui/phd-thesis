\section{Introduction} \label{ch:intro}

%% P1: Multi-threading is critical and popular.
Multi-threading has become increasing pervasive and critical because of two 
trends. First, due to physical constraints on circuit speed, computers are having
more and more cores rather than faster and faster single-core. In order to 
harness the power of multi-core, more and more software are multi-threaded. 
Second, the emerging cloud computing trend requires web services, ranging from 
web servers to databases, to process more and more requests at the same time, which also 
pushes developers to write more and more multi-threaded programs in order to 
process a large amount of requests concucurrenlty. These trends continue and 
then multit-threading are becoming increaingly pervasive and critical.

%% P2: However, it is hard to get right.
Unfortunately, despite much efforts from both academia and industry, 
multi-threaded programs are still notoriously difficult to get right. A key 
reason is: even running on the same input, the concurrently running threads of 
a program may interleave in \v{too many} different ways, and we call these interleavings 
\v{schedules}. Considering all inputs, this number is even larger. 
It is extremely hard to test, analyze, and verify all these huge 
amount of possible schedules and make sure these programs are reliable to 
concurrency bugs. As a result, a concurency bug hidden in one schedule can 
simply bypass these reliability techniques and show up in the field, 
potentially causing program crashes, wrong outputs, security breaches, and so on.

%% P3: DMT: one possible approach. And its limitations.
In order to reduce the number possible schedules on each input, researchers 
have proposed a great idea called deterministic multithreading (or \dmt) that 
always enforces the same schedule on the same input. By mapping each input to onely 
one schedule, \dmt greatly improved reliability for multithreaded programs on each input.

%% P4: StableMT: our new approach and thesis.
However, although \dmt is useful, it is not as useful as commonly perceived, 
because as we have shown in our previous research~\cite{cui:tern:osdi10},
a typical \dmt system can map slightly different inputs to 
very different schedules, artificially reducing programs' robustness on input 
perturbation, and the number of possible schedules on all inputs are still too 
many.

%% P5: StableMT's applications.
By greatly reducing the number of possible schedules for all inputs, \smt can benefit many reliability 
techniques and make it much easier to find the schedules that cause concurrency 
bugs. For example, my collaborators and I have quantitatively shown that \smt can 
increase the coverage of tools that systematically testing schedules for 
bugs~\cite{parrot:sosp13, dbug:spin11, modist:nsdi09}, and improve the precision 
of program analysis~\cite{wu:pldi12}, verification~\cite{wu:pldi12}, and 
debugging concurrency bugs~\cite{cui:tern:osdi10}. Some of our \smt techniques have 
also been used by other researchers to compute schedules for covering all 
inputs~cite{bergan:oopsla13}. We also plan to leverage \smt to enable transparent 
state-machine replication~\cite{paxos} for multi-threaded prograsms.

%% P6: Structures of this proposal.
The rest of this thesis is orgnized as follows. 


\tern TBD.

\peregrine TBD.

\parrot TBD.

Our \smt systems have broad applications.

Applying \smt to improving model checking coverage.

Applying \smt to build transparent multithreaded state machine replication systems.

The rest of the article is organized as follows.

