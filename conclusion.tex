\chapter{Conclusion} \label{sec:conclusion}

Multithreading is notoriously difficult to get right, and our research reveals
that a key reason is that a multithreaded program may run into exponentially 
many
possible schedules for all inputs at runtime, which brings a series of
significant reliability and security challenges on understanding,
testing, debugging, analyzing, and verification of multithreaded
programs.

To reduce the number of possible schedules and make multithreaded
programs easier to get right, we have invented a new idea called Stable
Multithreading (or \smt) that reuses each schedule on a wide range of inputs,
greatly reducing the number of possible schedules for all inputs. Through
building three \smt systems, \tern, \peregrine, and \parrot, with each 
addressing
a distinct research challenge, we have shown that \smt can be made simple, fast,
and deployable. Through applying \smt to make reproducing concurrency bugs
easier, to improve precision of static program analysis, and to increase
coverage of model checking tools, we have quantitatively demonstrated \smt's 
advantages on improving software reliability. All the source code,
benchmarks, and raw evaluation results of our latest \smt system \parrot are
available at \github. \smt has attracted the community's interests, and some 
techniques and ideas in our previous systems have been leveraged by 
University of Washington researchers to compute a small set of schedules to 
cover all or most inputs of multithreaded programs.

By addressing the key reason that causes multithreading difficult to get right,
\smt has broad applications on software reliability and security. In the 
future, we plan to apply \smt to make replication and verification of 
multithreaded programs easier, and to defend against security attacks 
that leverage concurrency bugs.