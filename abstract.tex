Multithreaded programs have become pervasive and critical due to the
accelerating computational demand and the rise of the multi-core hardware.
Unfortunately, despite decades of research and engineering effort, these
programs are still notoriously difficult to get right, and they are plagued with
harmful concurrency bugs that can cause wrong outputs, program crashes, security
breaches, and so on. Our study reveals that a root cause of this difficulty is
that multithreaded programs have too many possible thread interleavings (or
schedules) at runtime, probably due to performance favor. Even given only a
single input, a program may run into excessive schedules, depending on such
factors as hardware timing and OS scheduling. Considering all inputs, the number
of schedules is even much greater. It is extremely challenging to understand,
test, analyze, and verify this huge amount of schedules in a multithreaded
program and make sure all these schedules are free of concurrency bugs, thus
multithreaded programs are extremely difficult to get right.

In order to reduce the number of schedules for all inputs, we have studied the
relation between inputs and schedules of real-world programs, and made an
eye-opening discovery: many programs need only a small set of schedules to
efficiently process a wide range of inputs! Leveraging this discovery, we have
proposed a new idea called Stable Multi-Threading (StableMT) that reuses each
schedule on a wide range of inputs, greatly reducing the number of possible
schedules for all inputs. By addressing the root cause that makes multithreading
difficult to get right, StableMT makes greatly simplifies understanding,
testing, analyzing, and verification of multithreaded programs. In order to make
StableMT real, we have built three StableMT systems, \tern, \peregrine, and
\parrot, with each addressing a distinct research challenge. To demonstrate
StableMT's potential, we have quantitatively shown that StableMT can benefit
existing reliability techniques, including: (1) making reproducing real-world
concurrency bugs much easier; (2) greatly increasing coverage of model checking,
a systematic testing technique, by many orders of magnitudes; and (3) greatly
improving precision of static program analysis, leading to several new harmful
data races detected in heavily-studied programs.

