Multithreaded programs have become pervasive and critical due to the rise of the
multi-core hardware and the accelerating computational demand.
Unfortunately, despite decades of research and engineering effort, these
programs are still notoriously difficult to get right, and they are plagued with
harmful concurrency bugs that can cause wrong outputs, program crashes, security
breaches, and so on. Our study reveals that a key reason of this difficulty is
that multithreaded programs have too many possible thread interleavings (or
schedules) at runtime, probably due to performance favor. Even given only a
single input, a program may run into excessive schedules, depending on such
factors as hardware timing and OS scheduling. Considering all inputs, the number
of schedules is even much greater. It is extremely challenging to understand,
test, analyze, or verify this huge amount of schedules for a
multithreaded program and make sure all these schedules are free of concurrency
bugs, thus multithreaded programs are extremely difficult to get right.

In order to reduce the number of possible schedules and make multithreading
easier to get right, we have studied the
relation between inputs and schedules of real-world programs, and made an
interesting discovery: many programs need only a small set of schedules to
efficiently process a wide range of inputs! Leveraging this discovery, we have
proposed a new idea called Stable Multithreading (StableMT) that reuses each
schedule on a wide range of inputs, greatly reducing the number of possible
schedules for all inputs. By addressing the key reason that makes multithreading
difficult to get right, StableMT can make understanding,
testing, analyzing, and verification of multithreaded programs much
easier. To realize \smt, we have built three StableMT systems, \tern,
\peregrine, and \parrot, with each addressing a distinct research challenge.
Evaluation on a wide range of 108 popular multithreaded programs in
our latest \smt system, \parrot, shows that \smt is simple, fast, and
deployable.

To demonstrate \smt's potential, we have quantitatively demonstrated that \smt 
can benefit existing reliability tools, including: (1) making reproducing
real-world concurrency bugs much easier;  (2) greatly improving precision of
static program analysis, leading to several new harmful data races detected in
heavily-studied programs; and (3) greatly increasing coverage of model checking,
a systematic testing technique, by many orders of magnitudes. All the source
code, entire benchmarks, and raw evaluation results of our latest \smt system,
\parrot, are available at: \github.

